<! DOCTYPE html >
<html lang="en">
<head>
  <meta charset="UTF-8" />
 
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTF Data Dashboard</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 2rem;
      max-width: 1200px;
      margin: 0 auto;
      color: #333;
      line-height: 1.5;
    }
    .charts-section {
  margin-top: 2rem;
}

.chart-container {
  margin-top: 2rem;
  padding: 1.5rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  background-color: #f9f9f9;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
    /* Add to the style section in the head (around line 30) */
.timeline-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1.5rem;
  padding: 1rem;
  background-color: #f0f0f0;
  border-radius: 6px;
}

button {
  padding: 0.5rem 1rem;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-top: 1.5rem;
}

button:hover {
  background-color: #2980b9;
}

canvas {
  width: 100% !important;
  max-height: 400px;
}
    
    h1 {
      color: #2c3e50;
      margin-bottom: 1.5rem;
      border-bottom: 2px solid #eee;
      padding-bottom: 0.5rem;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
    }
    
    select, input {
      margin: 0.25rem 0;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      min-width: 150px;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }
    
    .summary, .stock-result {
      margin-top: 2rem;
      padding: 1.5rem;
      border: 1px solid #ddd;
      border-radius: 8px;
      background-color: #f9f9f9;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .summary h3, .stock-result h3 {
      margin-top: 0;
      color: #2c3e50;
      border-bottom: 1px solid #eee;
      padding-bottom: 0.5rem;
    }
    
    #summaryList {
      list-style-type: none;
      padding-left: 0;
    }
    
    #summaryList li {
      padding: 0.5rem 0;
      border-bottom: 1px solid #eee;
    }
    
    #summaryList li:last-child {
      border-bottom: none;
    }
    
    .loading {
      display: none;
      margin: 1rem 0;
      font-style: italic;
      color: #666;
    }
    
    .error {
      color: #e74c3c;
      font-weight: bold;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }
      
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      .stock-chart-container {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid #eee;
      }
      
      select, input {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <h1>MTF Data Search</h1>

  <div class="controls">
    <div class="control-group">
      <label for="yearSelect">Year:</label>
      <select id="yearSelect"></select>
    </div>

    <div class="control-group">
      <label for="monthSelect">Month:</label>
      <select id="monthSelect"></select>
    </div>

    <div class="control-group">
      <label for="dateSelect">Date:</label>
      <select id="dateSelect"></select>
    </div>

    <div class="control-group">
      <label for="stockInput">Search Stock:</label>
      <input list="stockList" id="stockInput" placeholder="Enter stock name" />
      <datalist id="stockList"></datalist>
    </div>
  </div>

  <div class="loading" id="loadingIndicator">Loading data...</div>
  
  <div class="summary" id="summaryBox">
    <h3>Summary</h3>
    <ul id="summaryList"></ul>
  </div>

  <div class="stock-result" id="stockBox">
    <h3>Stock Details</h3>
    <p><strong>Stock:</strong> <span id="stockName"></span></p>
    <p><strong>Summary:</strong> <span id="stockSummary"></span></p>
    <p><strong>Qty Fin (Cr):</strong> <span id="stockC"></span></p>
    <p><strong>Amt Fin (Cr):</strong> <span id="stockD"></span></p>
    <!-- Add this inside the stock-result div with id="stockBox" -->
    <div class="stock-chart-container">
      <canvas id="individualStockChart"></canvas>
    </div>
  </div>
  <div class="charts-section">
  <h2>Data Visualization</h2>
  
  <div class="chart-container">
    <h3>Summary Chart</h3>
    <canvas id="summaryChart"></canvas>
  </div>
  
  <div class="chart-container">
    <h3>Stock Details Chart</h3>
    <p>Top 10 stocks by amount financed</p>
    <canvas id="stockChart"></canvas>
  </div>
</div>

  <!-- Add just before the closing </div> of the charts-section div (around line 217) -->
<div class="chart-container" id="timelineAnalysisContainer">
  <h3>Timeline Analysis</h3>
  
  <div class="timeline-controls">
  <div class="control-group">
    <label for="startYearSelect">Start Year:</label>
    <select id="startYearSelect"></select>
  </div>
  <div class="control-group">
    <label for="startMonthSelect">Start Month:</label>
    <select id="startMonthSelect"></select>
  </div>
  <div class="control-group">
    <label for="startDateSelect">Start Date (Optional):</label>
    <select id="startDateSelect">
      <option value="">All Dates</option>
    </select>
  </div>
  <div class="control-group">
    <label for="endYearSelect">End Year:</label>
    <select id="endYearSelect"></select>
  </div>
  <div class="control-group">
    <label for="endMonthSelect">End Month:</label>
    <select id="endMonthSelect"></select>
  </div>
  <div class="control-group">
    <label for="endDateSelect">End Date (Optional):</label>
    <select id="endDateSelect">
      <option value="">All Dates</option>
    </select>
  </div>
  <div class="control-group">
    <label for="timelineStockSelect">Filter Stock (Optional):</label>
    <select id="timelineStockSelect">
      <option value="">All Stocks</option>
    </select>
  </div>
  <div class="control-group">
    <button id="loadTimelineBtn">Load Timeline</button>
  </div>
  </div>
  
  <canvas id="timelineChart"></canvas>
</div>

<script>
// Add these functions near the end of the script, before the DOMContentLoaded event

/**
 * Populates the timeline stock filter dropdown with stocks from currently selected date
 */
async function populateTimelineStockFilter() {
  const stockSelect = document.getElementById('timelineStockSelect');
  
  // Clear existing options
  stockSelect.innerHTML = '<option value="">All Stocks</option>';
  
  // Check if we have current data loaded from the main form
  if (currentData && currentData.stocks) {
    console.log('Using stocks from currently loaded data');
    const sortedStocks = Object.keys(currentData.stocks).sort();
    
    sortedStocks.forEach(stock => {
      const option = document.createElement('option');
      option.value = stock;
      option.textContent = stock;
      stockSelect.appendChild(option);
    });
    
    console.log(`Populated timeline stock filter with ${sortedStocks.length} stocks from current date`);
    return;
  }
  
  // Fallback: Try to get stocks from currently selected date in main form
  const selectedYear = document.getElementById('yearSelect').value;
  const selectedMonth = document.getElementById('monthSelect').value;
  const selectedDate = document.getElementById('dateSelect').value;
  
  if (selectedYear && selectedMonth && selectedDate) {
    try {
      const filePath = `${FOLDER_PATH}/${selectedYear}/${selectedMonth}/${selectedDate}`;
      const response = await fetch(filePath);
      
      if (response.ok) {
        const data = await response.json();
        if (data.stocks) {
          const sortedStocks = Object.keys(data.stocks).sort();
          
          sortedStocks.forEach(stock => {
            const option = document.createElement('option');
            option.value = stock;
            option.textContent = stock;
            stockSelect.appendChild(option);
          });
          
          console.log(`Populated timeline stock filter with ${sortedStocks.length} stocks from selected date`);
          return;
        }
      }
    } catch (error) {
      console.error('Error loading stocks from selected date:', error);
    }
  }
  
  // Final fallback: Sample from recent files
  console.log('Using fallback method to populate stock filter');
  try {
    const allStocks = new Set();
    
    // Get all years
    const yearsResponse = await fetch(`${FOLDER_PATH}/index.json`);
    const yearsData = await yearsResponse.json();
    const availableYears = yearsData.items;
    
    // Sample a few recent dates to get stock names
    for (const year of availableYears.slice(-2)) { // Last 2 years
      try {
        const monthsResponse = await fetch(`${FOLDER_PATH}/${year}/index.json`);
        const monthsData = await monthsResponse.json();
        const availableMonths = monthsData.items.slice(-3); // Last 3 months
        
        for (const month of availableMonths) {
          try {
            const datesResponse = await fetch(`${FOLDER_PATH}/${year}/${month}/index.json`);
            const datesData = await datesResponse.json();
            const availableDates = datesData.items.filter(file => file.endsWith('.json') && file !== 'index.json').slice(-5); // Last 5 dates
            
            for (const dateFile of availableDates) {
              try {
                const filePath = `${FOLDER_PATH}/${year}/${month}/${dateFile}`;
                const response = await fetch(filePath);
                
                if (response.ok) {
                  const data = await response.json();
                  if (data.stocks) {
                    Object.keys(data.stocks).forEach(stock => allStocks.add(stock));
                  }
                }
              } catch (err) {
                continue;
              }
            }
          } catch (err) {
            continue;
          }
        }
      } catch (err) {
        continue;
      }
    }
    
    // Add all found stocks
    const sortedStocks = Array.from(allStocks).sort();
    sortedStocks.forEach(stock => {
      const option = document.createElement('option');
      option.value = stock;
      option.textContent = stock;
      stockSelect.appendChild(option);
    });
    
    console.log(`Populated timeline stock filter with ${sortedStocks.length} stocks using fallback method`);
    
  } catch (error) {
    console.error('Error populating timeline stock filter:', error);
  }
}

/**
 * Loads data for the timeline across a date range with optional date filtering
 */
async function loadTimelineData(startYear, startMonth, startDate, endYear, endMonth, endDate, selectedStock) {
  console.log(`Loading timeline data from ${startYear}/${startMonth}/${startDate || 'all dates'} to ${endYear}/${endMonth}/${endDate || 'all dates'}`);
  if (selectedStock) {
    console.log(`Filtering for stock: ${selectedStock}`);
  }
  showLoading();
  
  try {
    // Create date objects for comparison only if specific dates are provided
    let startDateObj = null;
    let endDateObj = null;
    
    if (startDate) {
      const startDay = startDate.replace('.json', '');
      startDateObj = new Date(`${startYear}-${startMonth}-${startDay}`);
    }
    
    if (endDate) {
      const endDay = endDate.replace('.json', '');
      endDateObj = new Date(`${endYear}-${endMonth}-${endDay}`);
    }
    
    // If both dates are specified, validate range
    if (startDateObj && endDateObj && endDateObj < startDateObj) {
      throw new Error('End date must be after start date');
    }
    
    // Collect data for each date in the range
    const timelineData = [];
    let successCount = 0;
    let failCount = 0;
    
    // First, get all available years
    const yearsResponse = await fetch(`${FOLDER_PATH}/index.json`);
    const yearsData = await yearsResponse.json();
    const availableYears = yearsData.items;
    
    // For specific stock tracking
    const stockTimelineData = [];
    
    for (const year of availableYears) {
      // Skip years outside our range
      if (year < startYear || year > endYear) continue;
      
      // Get months for this year
      const monthsResponse = await fetch(`${FOLDER_PATH}/${year}/index.json`);
      if (!monthsResponse.ok) {
        console.log(`Could not load months for year ${year}`);
        continue;
      }
      
      const monthsData = await monthsResponse.json();
      const availableMonths = monthsData.items;
      
      for (const month of availableMonths) {
        // Skip months outside our range
        if ((year === startYear && month < startMonth) || 
            (year === endYear && month > endMonth)) {
          continue;
        }
        
        // Get dates for this month
        const datesResponse = await fetch(`${FOLDER_PATH}/${year}/${month}/index.json`);
        if (!datesResponse.ok) {
          console.log(`Could not load dates for ${year}/${month}`);
          continue;
        }
        
        const datesData = await datesResponse.json();
        const availableDates = datesData.items.filter(file => file.endsWith('.json') && file !== 'index.json');
        
        for (const dateFile of availableDates) {
          const day = dateFile.replace('.json', '');
          const currentDate = new Date(`${year}-${month}-${day}`);
          
          // Skip dates outside our range only if specific dates are provided
          if (startDateObj && currentDate < startDateObj) continue;
          if (endDateObj && currentDate > endDateObj) continue;
          
          // Fetch data for this specific date
          try {
            const filePath = `${FOLDER_PATH}/${year}/${month}/${dateFile}`;
            console.log(`Attempting to fetch: ${filePath}`);
            
            const response = await fetch(filePath);
            
            if (!response.ok) {
              console.log(`No data available at ${filePath}`);
              failCount++;
              continue;
            }
            
            const data = await response.json();
            
            if (selectedStock && data && data.stocks && data.stocks[selectedStock]) {
              // If specific stock is selected and exists in this date's data
              stockTimelineData.push({
                date: `${year}-${month}-${day}`,
                formattedDate: `${day}-${month}-${year}`,
                amount: data.stocks[selectedStock].Amount_in_crores || 0,
                quantity: data.stocks[selectedStock].Quantity_in_crores || 0
              });
              successCount++;
            }
            else if (!selectedStock && data && data.summary && data.summary.length > 0) {
              console.log(`Found data for ${year}-${month}-${day}`);
              timelineData.push({
                date: `${year}-${month}-${day}`,
                formattedDate: `${day}-${month}-${year}`,
                data: data.summary
              });
              successCount++;
            } else {
              console.log(`No relevant data in file at ${filePath}`);
              failCount++;
            }
          } catch (err) {
            console.log(`Error processing ${year}/${month}/${dateFile}: ${err.message}`);
            failCount++;
          }
        }
      }
    }
    
    console.log(`Timeline data load complete: ${successCount} successful, ${failCount} failed`);
    
    if (selectedStock && stockTimelineData.length > 0) {
      // Sort by date and create stock-specific timeline
      stockTimelineData.sort((a, b) => new Date(a.date) - new Date(b.date));
      createStockTimelineChart(stockTimelineData, selectedStock);
    } else if (!selectedStock && timelineData.length > 0) {
      // Sort timeline data by date for regular summary view
      timelineData.sort((a, b) => new Date(a.date) - new Date(b.date));
      createTimelineChart(timelineData);
    } else {
      const errorMessage = selectedStock ? 
        `No data found for stock "${selectedStock}" in the selected date range.` : 
        `No data found in the selected date range.`;
      
      throw new Error(`${errorMessage} Please try a different date range or stock.`);
    }
    
  } catch (error) {
    console.error('Error loading timeline data:', error);
    showError(`Failed to load timeline data: ${error.message}`);
  } finally {
    hideLoading();
  }
}

/**
 * Creates a timeline chart showing trends over the selected date range
 */
function createTimelineChart(timelineData) {
  const ctx = document.getElementById('timelineChart');
  
  // Check if a chart instance already exists and destroy it
  if (window.timelineChartInstance) {
    window.timelineChartInstance.destroy();
  }
  
  if (!timelineData || timelineData.length === 0) {
    console.log('No timeline data available for chart');
    return;
  }
  
  // Prepare data for charting
  const labels = timelineData.map(item => item.formattedDate);
  
  // Track all unique particulars across all days
  const allParticulars = new Set();
  timelineData.forEach(day => {
    day.data.forEach(item => {
      if (item.particular) {
        allParticulars.add(item.particular);
      }
    });
  });
  
  // Create datasets for each particular
  const datasets = [];
  const colors = [
    'rgba(54, 162, 235, 1)',
    'rgba(255, 99, 132, 1)',
    'rgba(75, 192, 192, 1)',
    'rgba(255, 159, 64, 1)',
    'rgba(153, 102, 255, 1)',
    'rgba(255, 205, 86, 1)',
    'rgba(201, 203, 207, 1)'
  ];
  
  Array.from(allParticulars).forEach((particular, index) => {
    const data = timelineData.map(day => {
      const summaryItem = day.data.find(item => item.particular === particular);
      return summaryItem ? summaryItem.amount_crores : null;
    });
    
    datasets.push({
      label: particular,
      data: data,
      borderColor: colors[index % colors.length],
      backgroundColor: colors[index % colors.length].replace('1)', '0.2)'),
      fill: false,
      tension: 0.1
    });
  });
  
  // Create chart
  window.timelineChartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: datasets
    },
    options: {
      responsive: true,
      scales: {
        y: {
          beginAtZero: false,
          title: {
            display: true,
            text: 'Amount (Cr)'
          }
        },
        x: {
          title: {
            display: true,
            text: 'Date'
          },
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              return `${context.dataset.label}: ₹${context.parsed.y ? context.parsed.y.toLocaleString() : 'N/A'} Cr`;
            }
          }
        },
        legend: {
          position: 'top',
        }
      }
    }
  });
}

/**
 * Creates a timeline chart for a specific stock
 */
function createStockTimelineChart(stockTimelineData, stockName) {
  const ctx = document.getElementById('timelineChart');
  
  // Check if a chart instance already exists and destroy it
  if (window.timelineChartInstance) {
    window.timelineChartInstance.destroy();
  }
  
  if (!stockTimelineData || stockTimelineData.length === 0) {
    console.log('No timeline data available for this stock');
    return;
  }
  
  // Prepare data for charting
  const labels = stockTimelineData.map(item => item.formattedDate);
  const amounts = stockTimelineData.map(item => item.amount);
  const quantities = stockTimelineData.map(item => item.quantity);
  
  // Create chart
  window.timelineChartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [
        {
          label: `${stockName} Amount (Cr)`,
          data: amounts,
          borderColor: 'rgba(255, 99, 132, 1)',
          backgroundColor: 'rgba(255, 99, 132, 0.2)',
          fill: false,
          tension: 0.1,
          yAxisID: 'y'
        },
        {
          label: `${stockName} Quantity (Cr)`,
          data: quantities,
          borderColor: 'rgba(54, 162, 235, 1)',
          backgroundColor: 'rgba(54, 162, 235, 0.2)',
          fill: false,
          tension: 0.1,
          yAxisID: 'y1'
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        y: {
          type: 'linear',
          display: true,
          position: 'left',
          beginAtZero: false,
          title: {
            display: true,
            text: 'Amount (Cr)'
          }
        },
        y1: {
          type: 'linear',
          display: true,
          position: 'right',
          grid: {
            drawOnChartArea: false
          },
          beginAtZero: false,
          title: {
            display: true,
            text: 'Quantity (Cr)'
          }
        },
        x: {
          title: {
            display: true,
            text: 'Date'
          },
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              const value = context.parsed.y ? context.parsed.y.toLocaleString() : 'N/A';
              return `${context.dataset.label}: ${value} Cr`;
            }
          }
        },
        legend: {
          position: 'top',
        },
        title: {
          display: true,
          text: `Timeline Analysis for ${stockName}`
        }
      }
    }
  });
}

/**
 * Helper function to populate any dropdown given an ID, specific to timeline controls
 */
function populateTimelineDropdown(id, items) {
  const dropdown = document.getElementById(id);
  const isDateDropdown = id.includes('Date');
  
  if (isDateDropdown) {
    dropdown.innerHTML = '<option value="">All Dates</option>';
  } else {
    dropdown.innerHTML = '<option value="">--Select--</option>';
  }
  
  if (items && items.length > 0) {
    items.forEach(item => {
      dropdown.innerHTML += `<option value="${item}">${item}</option>`;
    });
  }
}

// Add these event listeners to the existing DOMContentLoaded event handler
document.addEventListener('DOMContentLoaded', function() {
  // ... existing code ...
  
  // Set up the Date dropdown change event
  document.getElementById('dateSelect').addEventListener('change', function() {
    const selectedYear = document.getElementById('yearSelect').value;
    const selectedMonth = document.getElementById('monthSelect').value;
    const selectedDate = this.value;
    console.log(`Date selection changed to: ${selectedDate}`);
    
    if (selectedYear && selectedMonth && selectedDate) {
      loadStockData(selectedYear, selectedMonth, selectedDate);
    }
  });
  
  // Set up the stock search input event
  document.getElementById('stockInput').addEventListener('input', function() {
    displayStockDetails(this.value);
  });

  // Initialize timeline controls
  document.getElementById('startYearSelect').addEventListener('change', function() {
    const selectedYear = this.value;
    
    // Reset dependent dropdowns
    document.getElementById('startMonthSelect').innerHTML = '<option value="">--Select--</option>';
    document.getElementById('startDateSelect').innerHTML = '<option value="">All Dates</option>';
    
    if (selectedYear) {
      // Load months for the selected year
      showLoading();
      fetch(`${FOLDER_PATH}/${selectedYear}/index.json`)
        .then(response => response.json())
        .then(data => {
          populateTimelineDropdown('startMonthSelect', data.items);
          hideLoading();
        })
        .catch(error => {
          console.error('Error loading months:', error);
          hideLoading();
        });
    }
  });
  
  document.getElementById('startMonthSelect').addEventListener('change', function() {
    const selectedYear = document.getElementById('startYearSelect').value;
    const selectedMonth = this.value;
    
    // Reset dependent dropdown
    document.getElementById('startDateSelect').innerHTML = '<option value="">All Dates</option>';
    
    if (selectedYear && selectedMonth) {
      // Load dates for the selected year/month
      showLoading();
      fetch(`${FOLDER_PATH}/${selectedYear}/${selectedMonth}/index.json`)
        .then(response => response.json())
        .then(data => {
          const dateFiles = data.items.filter(file => file.endsWith('.json') && file !== 'index.json');
          populateTimelineDropdown('startDateSelect', dateFiles);
          hideLoading();
        })
        .catch(error => {
          console.error('Error loading dates:', error);
          hideLoading();
        });
    }
  });
  
  document.getElementById('endYearSelect').addEventListener('change', function() {
    const selectedYear = this.value;
    
    // Reset dependent dropdowns
    document.getElementById('endMonthSelect').innerHTML = '<option value="">--Select--</option>';
    document.getElementById('endDateSelect').innerHTML = '<option value="">All Dates</option>';
    
    if (selectedYear) {
      // Load months for the selected year
      showLoading();
      fetch(`${FOLDER_PATH}/${selectedYear}/index.json`)
        .then(response => response.json())
        .then(data => {
          populateTimelineDropdown('endMonthSelect', data.items);
          hideLoading();
        })
        .catch(error => {
          console.error('Error loading months:', error);
          hideLoading();
        });
    }
  });
  
  document.getElementById('endMonthSelect').addEventListener('change', function() {
    const selectedYear = document.getElementById('endYearSelect').value;
    const selectedMonth = this.value;
    
    // Reset dependent dropdown
    document.getElementById('endDateSelect').innerHTML = '<option value="">All Dates</option>';
    
    if (selectedYear && selectedMonth) {
      // Load dates for the selected year/month
      showLoading();
      fetch(`${FOLDER_PATH}/${selectedYear}/${selectedMonth}/index.json`)
        .then(response => response.json())
        .then(data => {
          const dateFiles = data.items.filter(file => file.endsWith('.json') && file !== 'index.json');
          populateTimelineDropdown('endDateSelect', dateFiles);
          hideLoading();
        })
        .catch(error => {
          console.error('Error loading dates:', error);
          hideLoading();
        });
    }
  });
  
  // Load Timeline button event listener
  document.getElementById('loadTimelineBtn').addEventListener('click', function() {
    const startYear = document.getElementById('startYearSelect').value;
    const startMonth = document.getElementById('startMonthSelect').value;
    const startDate = document.getElementById('startDateSelect').value || null; // Allow null for "All Dates"
    const endYear = document.getElementById('endYearSelect').value;
    const endMonth = document.getElementById('endMonthSelect').value;
    const endDate = document.getElementById('endDateSelect').value || null; // Allow null for "All Dates"
    const selectedStock = document.getElementById('timelineStockSelect').value;
    
    if (startYear && startMonth && endYear && endMonth) {
      // Log exactly what we're working with
      console.log("Start date components:", startYear, startMonth, startDate || 'all dates');
      console.log("End date components:", endYear, endMonth, endDate || 'all dates');
      console.log("Selected stock:", selectedStock || 'all stocks');
      
      loadTimelineData(startYear, startMonth, startDate, endYear, endMonth, endDate, selectedStock);
    } else {
      alert('Please select at least start and end year/month');
    }
  });
  
  // Initialize timeline year dropdowns and stock filter
  fetch(`${FOLDER_PATH}/index.json`)
    .then(response => response.json())
    .then(data => {
      populateTimelineDropdown('startYearSelect', data.items);
      populateTimelineDropdown('endYearSelect', data.items);
      
      // Populate stock filter initially
      populateTimelineStockFilter();
    })
    .catch(error => console.error('Error loading years for timeline:', error));
  
  // Also add event listener to refresh stock filter when main date selection changes
  const dateSelect = document.getElementById('dateSelect');
  if (dateSelect) {
    const originalChangeHandler = dateSelect.onchange;
    dateSelect.addEventListener('change', function() {
      // Call original handler first
      if (originalChangeHandler) {
        originalChangeHandler.call(this);
      }
      
      // Then refresh timeline stock filter with new date's stocks
      setTimeout(() => {
        populateTimelineStockFilter();
      }, 1000); // Small delay to ensure data is loaded
    });
  }
});
</script>
</body>
</html>
